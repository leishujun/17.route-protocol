cat /etc/services     查看Linux中已经定义的端口号，可修改范围
cat  /proc/sys/net/ipv4/ip_local_port_range     查看默认端口范围，代理服务器需要的端口号要多
/proc/sys/net/ipv4/tcp_max_syn_backlog        半连接队列建议大小>1024
/proc/sys/net/ipv4/somaxconn                        全连接队列建议大小>1024
/proc/sys/net/ipv4/tcp_max_orphans               内核能接管的最大孤儿连接数
/proc/sys/net/ipv4/tcp_fin_timeout                  孤儿连接在内核中生存的时间
/proc/sys/net/ipv4/tcp_retries1，指定在底层IP接管之前TCP最少执行的重传
次数，默认值是3
/proc/sys/net/ipv4/tcp_retries2，指定连接放弃前TCP最多可以执行的重传次
数，默认值15（一般对应13～30min）
/proc/sys/net/ipv4/tcp_congestion_control     当前所使用的TCP拥塞控制算法，一般是cubic
（reno算法、vegas算法和cubic算法）
/proc/sys/net/ipv4/icmp_echo_ignore_all   禁ping
/proc/sys/net/ipv4/ip_default_ttl     默认生存时间64

ICMP intnet层协议  intnet control  message  protocol


                                  ----------------------《以太网协议》--------------------

                                                 以太网帧结构
------------------------------------------------------------------------------------
   8                6               6         2                       46-1500                                  4
Frame   Destination   Source  Type                       Data                                   FCS    
                                                            Intnet层   传输层   应用层  数据
                                                               IP           TCP      APP   DATA
                                                            --------------------------------


     8                6                    6               2        46-1500           4          ------>单位都是字节byte，换算成更低一级的就是bit位
Preamble   DestMAC    SourceMAC   Type         Data            FCS



Preamble：前导信息

DestMAC   目的物理地址，MAC，media  access control

SourceMAC    源物理地址

Type   上层协议类型

Data    数据   里面可能包含网络层、传输层、应用层等头部信息

FCS：校验位

以太网帧的范围
72-1526字节

实际上前面8个和后面4个字节相对而言并不是很不重要，实际意义并不大
抓包软件都会把这两部分的内容直接过滤出去，所以我们在Wireshark等
软件中看到的信息只有

60-1514

个字节



                                  ----------------------《TCP/IP协议栈》--------------------
Transport Control Protocol
Intnet Protocol


Transmission control protocol     Intnet protocol  面向连接，意思是说在通讯双方
在连接之前先确认能否正常通讯，有点像每天早上高铁第一趟车空车在铁路上跑一一遍，先检车路上是否正常，再载人
sequence：序列号，TCP协议有序列号
acknowledgement：确认号

User  Data  Protocol

TCP、IP、UDP、ICMP、RIP、TELNET、FTP、SMTP、ARP、HTTP等协议

应用层             HTTP、TELNET、FTP、SMTP、NFS、SNMP、DNS

传输层              TCP、UDP

intnet层

网络访问层


                                    TCP包头一行共32位
           ---------------------------------------------------------
        0                                         16                                          31
           ---------------------------------------------------------
           源端口                                                              目的端口
                                             序号
                                            确认号 
           数据偏移    保留    URG/ACK/PSH/RST/SYN/FIN    窗口
           检验和                                                              紧急指针
           选项（长度可变）                                                    填充



                                  ----------------------《端口》--------------------

端口号：2^16个，从0开始，0-65535，每个应用程序用一个端口，每个端口就相当于每个应用程序的家


C/S   B/S   B：浏览器  C：Client客户端   S：Server服务端

所有的0-1023端口都必须要用管理员权限运行
1024-49151端口用于用户端口或注册端口

ftp                             20、21
ssh                             22
Telnet                         23
smtp                           25   邮件
DHCP                         67服务器、68客户端
TFTP                            69
http                             80
kerberos                     88
pop3                          110    邮件
imap                           143
snmp                          161
https                           443
smb                            445   文件共享
微软的sql server         1433
oracle                        1521
mysql                         3306
memcached              11211

cat /etc/services     查看Linux中已经定义的端口号，可修改范围
cat  /proc/sys/net/ipv4/ip_local_port_range     查看默认端口范围，代理服务器需要的端口号要多


                                  ----------------------《序号》--------------------
seq
sequence                 2^32个数字，要是超过了重新开始，用时间标出

文件过大需要分成许多个包，每个包发送给对方要按照一定的顺序才能组合成原来的文件，就需要
这个序列号规定先后，否则文件收完后不知道顺序就不知道收到的是什么



                                  ----------------------《确认号》--------------------
ack
acknowledgement    2^43个数字，要是超过了重新开始，用时间标出

确认前面发送过来的包都收到了，所以这个号码是在发送方发过来的确认好基础上+1的号码







                                  ----------------------《数据偏移》--------------------


报文长度，所有字段的和，最大为60，包括，源端口，目的端口，序列号，确认号，数据偏移，保留字段
URG/ACK/PSH/RST/SYN/FIN，窗口，校验和，紧急指针，选项，填充部分




                                  ----------------------《保留》--------------------

用不上


                  ----------------------《URG/ACK/PSH/RST/SYN/FIN》--------------------
这里都用0或1标识

URG：紧急指针，有的话紧急指针那一栏写1的话代表那一栏的数据生效

ACK：虽然都是确认号，但是与上面的ack不同，1表示收到，这个只能用0或者1标识

PSH：接收的数据先放入网卡的buffer缓冲区，再复制到kernel内核buffer缓冲区，实际上前面
的都是属于TCP缓冲区，1的话表示立即从内核中复制数据到app应用程序的缓冲区

RST  reset，1的话与主机连接出现严重故障或是错误，那就重置连接

SYN     1表示同步

FIN   finish   1表示结束


                                  ----------------------《窗口大小》--------------------

规定从窗口开始还能发多少数据包
Window size value * Window size scaling factor两个相乘 
(此值在三次握手阶段TCP选项Window scale协商得到)
一般是第一次握手的时候就确定了Window size scaling factor的大小
在tcp的flags选项或是options选项里面有

如果window size=1 那么意思就是一个包用ACK确认一次
如果window size=10 那么意思就是10包用ACK确认一次
实际上固定窗口大小是不好的因为服务器的性能是时刻在变化的，因此
就要引用。


                                  ----------------------《校验和》--------------------

提供额外的可靠性

                                  ----------------------《紧急指针》--------------------


标记紧急数据在数据字段中的位置

                                  ----------------------《选项部分》--------------------

选项部分最长为：(2^4-1)*4-20=40字节


常见选项部分：

最大报文段长度：Maxium Segment Size，MSS，通常1460字节
去掉了TCP、IP协议的报文头部      1500-20-20=1460

最大报文段长度MSS（Maximum Segment Size）
指明自己期望对方发送TCP报文段时那个数据字段的长度。比如：1460字节。数
据字段的长度加上TCP首部的长度才等于整个TCP报文段的长度。MSS不宜设的太
大也不宜设的太小。若选择太小，极端情况下，TCP报文段只含有1字节数据，在
IP层传输的数据报的开销至少有40字节（包括TCP报文段的首部和IP数据报的首
部）。这样，网络的利用率就不会超过1/41。若TCP报文段非常长，那么在IP层传
输时就有可能要分解成多个短数据报片。在终点要把收到的各个短数据报片装配成
原来的TCP报文段。当传输出错时还要进行重传，这些也都会使开销增大。因此
MSS应尽可能大，只要在IP层传输时不需要再分片就行。在连接建立过程中，双
方都把自己能够支持的MSS写入这一字段。 MSS只出现在SYN报文中。即：MSS
出现在SYN=1的报文段中
MTU和MSS值的关系：MTU=MSS+IP Header+TCP Header
通信双方最终的MSS值=较小MTU-IP Header-TCP Header

窗口扩大：Window Scale
为了扩大窗口，由于TCP首部的窗口大小字段长度是16位，所以其表示的最大数是
65535。但是随着时延和带宽比较大的通信产生（如卫星通信），需要更大的窗口
来满足性能和吞吐率，所以产生了这个窗口扩大选项

时间戳： Timestamps
可以用来计算RTT(往返时间)，发送方发送TCP报文时，把当前的时间值放入时间
戳字段，接收方收到后发送确认报文时，把这个时间戳字段的值复制到确认报文中，
当发送方收到确认报文后即可计算出RTT。也可以用来防止回绕序号PAWS，也可
以说可以用来区分相同序列号的不同报文。因为序列号用32为表示，每2^32个序
列号就会产生回绕，那么使用时间戳字段就很容易区分相同序列号的不同报文


                                  ----------------------《填充部分》--------------------

当报文字段太短时，填数一些数据，使数据不至于太短，data中要求最短是 46字节


三次握手为什么是三次？
如果是两次的话无法确认双方发的消息都被彼此收到了，但是三次的话，双方之间的包就能确认都被收到了


                  ----------------------《和三次握手相关的sync半连接和accept全连接队列》--------------------
ss -lnt
/proc/sys/net/ipv4/tcp_max_syn_backlog    半连接队列建议大小>1024
/proc/sys/net/ipv4/somaxconn                    全连接队列建议大小>1024

实际上我们连接服务器的时候，服务器的连接数是有限制的，就像我们去饭店吃饭一样，能够提供给客户吃饭
的位置是有限的，如果里面已经坐满了人，我们是无法进去吃饭的，所以里面的位置就相当于是全连接队列。

而饭店又考虑到可能会有许多人的这种情况，所以在外面提供给客户等待的位置就相当于是半连接队列。但是等待
的位置也是有个数限制的。
如果任何一个队列满了的情况下，服务器是没有能力回应客户端的。

实际上上面这种队列是存在一些安全问题的。因此有些黑客攻击时候只需要制造出大量的肉机，去访问服务器，
把服务器的队列都给占满了，那么正常的客户就因为半连接的队列中都无法存放位置而有可能导致第一次握手都无法形成

或者黑客不断的发送SYN给服务器，但是等服务器发送ACK和SYN给他的机器时，那他就不发ACK包回应服务器
这样在一段时间内服务器就会一直等待黑客的机器发送确认包ACK给服务器，而不接受正常客户的正常访问，
从而导致服务器无法正常工作！

防止措施：
使用防火墙拒绝掉不正当的半连接行为！



三次握手、四次挥手总共11中状态
CLOSING、LISTEN、SYN_SENT、SYN_RECEIVED、ESTABLISHED、CLOSED
FIN-WAIT-1 、FIN-WAIT-2、TIME-WAIT、CLOSE-WAIT、LAST-ACK


                                  ----------------------《TCP拥塞控制》--------------------



慢启动（slow start）汽车加速那样不会一开始就加速到很高的速度，慢慢的加速

拥塞避免（congestion avoidance）当网络慢时，控制传输速度

快速重传（fastretransmit）

快速恢复（fast recovery）

拥塞控制算法在Linux下有多种实现，比如reno算法、vegas算法和cubic算法等。

/proc/sys/net/ipv4/tcp_congestion_control  查看算法





                                  ----------------------《UDP协议》--------------------

User  Data  Protocol
   源端口   目的端口
UDP长度    UDP校验和
          数据


                                  ----------------------《ARP协议》--------------------

Address Resolution Protocol 
地址解析协议

ARP协议的漏洞：广播发出后，只要有人应答不管是谁都相信，但是只相信第一次的，这是ARP天生的隐患，所以能被人
冒充成网关
解决方式：绑定网关的IP地址和网关的MAC地址

 广播实现

免费ARP
开机时为避免地址冲突发一个广播问广播域中的主机是否有人用本计算机的IP地址

arp -n
ip neigh  查看邻居信息

反向ARP
网吧无盘工作站，云服务，实际上就是利用这种特点。计算机本身不带硬盘，一开机
从服务器上读取所有数据，一关机，所有数据都清空，都没了！
云也是这中类似的方式，本身电脑上不放数据，把所有数据都放在远端服务器上，
只不过是无盘工作站的变形罢了！



                                  ----------------------《IP协议》--------------------
Intnet Protocol
----------------------------------
 4           4             8             16
版本  首部长度  区分服务    总长度
----------------------------------
 16                        3             13  
标识                    标志        片偏移
----------------------------------
    8             8                    16
生存时间   协议            首部检验和
----------------------------------
                      32
                   源地址
----------------------------------
                      32
                 目的地址
----------------------------------
     24                                     8
可选长度                          填充部分
----------------------------------                       
                 数据部分
----------------------------------------------------------------------------

版本:占4位,指 IP 协议的版本目前的IP协议版本号为4

首部长度:占4位,可表示的最大数值是15个单位，一个单位为4字节，因此IP 的
首部长度的最大值是60字节

区分服务:占8位,用来获得更好的服务,在旧标准中叫做服务类型,但实际上一直未
被使用过.后改名为区分服务.只有在使用区分服务(DiffServ)时,这个字段才起作
用.一般的情况下不使用

总长度:占16位,指首部和数据之和的长度,单位为字节,因此数据报的最大长度为
65535 字节.总长度必须不超过最大传送单元 MTU

标识:占16位,它是一个计数器,通常，每发送一个报文，该值会加1， 也用于数
据包分片，在同一个包的若干分片中，该值是相同的

标志(flag):占3位,目前只有后两位有意义，DF和DM
DF： Don’t Fragment 中间的一位，只有当 DF=0 时才允许分片
MF：More Fragment 最后一位，MF=1表示后面还有分片,MF=0 表示最后
一个分片

片偏移:占12位,指较长的分组在分片后，该分片在原分组中的相对位置.片偏移
以8个字节为偏移单位

生存时间:占8位,记为TTL (Time To Live) 数据报在网络中可通过的路由器数的
最大值,TTL 字段是由发送端初始设置一个 8 bit字段.推荐的初始值由分配数字
RFC 指定,当前值为 64.发送 ICMP 回显应答时经常把 TTL 设为最大值 255
默认：Windows 128  ， Linux 64

协议:占8位,指出此数据报携带的数据使用何种协议以便目的主机的IP层将数据
部分上交给哪个处理过程, 1表示为 ICMP 协议, 2表示为 IGMP 协议, 6表示为
TCP 协议, 17表示为 UDP 协议

首部检验和:占16位,只检验数据报的首部不检验数据部分.采用简单的计算方法

源地址和目的地址:都各占4字节,分别记录源地址和目的地址

----------------------------------------------------------------------------
IPV6  128位  IP地址个数2^128

IPV9  中国创建的，2001年启动 256位可扩展到2048 ，向下兼容IPV4，使用10
进制数字，可以经过验证再通讯，不像现在的主机只要知道对方的IP地址，直接就
ping对方就可以完成一次通讯




----------------------------------《《《《访问浏览器中的网页时，底层做了些什么事情？》》》----------------------
目前学习到的东西
1.先知道对方IP，不论通过哪种手段知道
2.判断是不是在一个网段
3.将对方的IP地址和本机的子网掩码做与运算，与出来的结果是相同就是同一网段，不是则不同
4.查找本地的路由表，查看是否有去往浏览器中IP地址的路由

                          UDP
本地路由、ARP、DNS、外部路由、三次握手、Data Send、Http或者Https